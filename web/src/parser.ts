/**
 * TreeSitter parser wrapper with AST serialization
 */

import { Parser, Language } from 'web-tree-sitter';

/** Serialized node format matching Rust's SerializedNode */
export interface SerializedNode {
  kind: string;
  isNamed: boolean;
  startRow: number;
  startCol: number;
  endRow: number;
  endCol: number;
  startByte: number;
  endByte: number;
  fieldName?: string;
  children: SerializedNode[];
}

// Tree-sitter runtime WASM
// @ts-ignore
import treeSitterWasm from 'web-tree-sitter/web-tree-sitter.wasm?url';

// Grammar WASM URLs - generated by `task grammars`
// Source of truth is in Taskfile.yml (npm/release/source per language)
import * as grammars from './grammars';

/** Language to grammar URL mapping */
const GRAMMAR_URLS: Record<string, string> = grammars;

let parser: Parser | null = null;
const loadedLanguages = new Map<string, Language>();

/**
 * Initialize the TreeSitter parser
 */
export async function initParser(): Promise<void> {
  await Parser.init({
    locateFile: () => treeSitterWasm,
  });
  parser = new Parser();
}

/**
 * Load a language grammar
 */
export async function loadLanguage(lang: string): Promise<Language> {
  if (loadedLanguages.has(lang)) {
    return loadedLanguages.get(lang)!;
  }

  const grammarUrl = GRAMMAR_URLS[lang];
  if (!grammarUrl) {
    throw new Error(`Unsupported language: ${lang}`);
  }

  const language = await Language.load(grammarUrl);
  loadedLanguages.set(lang, language);
  return language;
}

/**
 * Parse source code and return serialized AST
 */
export async function parseSource(source: string, lang: string): Promise<SerializedNode> {
  if (!parser) {
    await initParser();
  }

  const language = await loadLanguage(lang);
  parser!.setLanguage(language);

  const tree = parser!.parse(source);
  if (!tree) {
    throw new Error('Failed to parse source');
  }
  return serializeNode(tree.rootNode);
}

/**
 * Serialize a TreeSitter node to our JSON format
 */
function serializeNode(node: any, fieldName?: string): SerializedNode {
  const children: SerializedNode[] = [];

  // Use cursor to iterate children with field names
  const cursor = node.walk();
  if (cursor.gotoFirstChild()) {
    do {
      const child = cursor.currentNode;
      const childFieldName = cursor.currentFieldName ?? undefined;
      children.push(serializeNode(child, childFieldName));
    } while (cursor.gotoNextSibling());
  }

  return {
    kind: node.type,
    isNamed: node.isNamed,
    startRow: node.startPosition.row,
    startCol: node.startPosition.column,
    endRow: node.endPosition.row,
    endCol: node.endPosition.column,
    startByte: node.startIndex,
    endByte: node.endIndex,
    fieldName,
    children,
  };
}

/**
 * Get list of supported languages
 */
export function getSupportedLanguages(): string[] {
  return Object.keys(GRAMMAR_URLS);
}
