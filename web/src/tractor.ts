/**
 * Tractor WASM module wrapper
 */

import type { SerializedNode } from './parser';

// Import the WASM module (generated by wasm-pack)
// @ts-ignore - Module will be generated by wasm-pack
import init, {
  parseToXml,
  parseAstToXml,
  getSupportedLanguages,
  hasTransforms,
  extractSourceSnippet as wasmExtractSourceSnippet,
  getSourceLines as wasmGetSourceLines,
  getLanguageInfo as wasmGetLanguageInfo,
  getWebLanguages as wasmGetWebLanguages,
  validateXPath as wasmValidateXPath,
  prettyPrintXml as wasmPrettyPrintXml,
  highlightFullSource as wasmHighlightFullSource,
  getSchemaTree as wasmGetSchemaTree,
} from '../pkg/tractor_core.js';

let initialized = false;

/**
 * Initialize the Tractor WASM module
 */
export async function initTractor(): Promise<void> {
  if (initialized) return;
  await init();
  initialized = true;
}

/** Parse request format */
export interface ParseRequest {
  ast: SerializedNode;
  source: string;
  language: string;
  filePath?: string;
  rawMode?: boolean;
  includeLocations?: boolean;
  prettyPrint?: boolean;
}

/** Parse response format */
export interface ParseResponse {
  xml: string;
  warnings: string[];
}

/**
 * Parse AST to XML using the full request format
 */
export async function parseToXmlFull(request: ParseRequest): Promise<ParseResponse> {
  await initTractor();
  const responseJson = parseToXml(JSON.stringify(request));
  return JSON.parse(responseJson);
}

/**
 * Parse AST to XML using simple parameters
 */
export async function parseAstToXmlSimple(
  ast: SerializedNode,
  source: string,
  language: string,
  rawMode: boolean = false,
  includeLocations: boolean = true,
  prettyPrint: boolean = true
): Promise<string> {
  await initTractor();
  return parseAstToXml(JSON.stringify(ast), source, language, rawMode, includeLocations, prettyPrint);
}

/**
 * Get list of supported languages from the WASM module
 */
export async function getTractorLanguages(): Promise<string[]> {
  await initTractor();
  return JSON.parse(getSupportedLanguages());
}

/**
 * Check if a language has semantic transforms
 */
export async function languageHasTransforms(language: string): Promise<boolean> {
  await initTractor();
  return hasTransforms(language);
}

/**
 * Extract source snippet given start/end positions in "line:col" format
 */
export async function extractSourceSnippet(
  source: string,
  start: string,
  end: string
): Promise<string> {
  await initTractor();
  return wasmExtractSourceSnippet(source, start, end);
}

/**
 * Get full source lines for a range given "line:col" format positions
 * Returns the full lines from start position's line to end position's line
 */
export async function getSourceLines(
  source: string,
  start: string,
  end: string
): Promise<string[]> {
  await initTractor();
  const jsonLines = wasmGetSourceLines(source, start, end);
  return JSON.parse(jsonLines);
}

/**
 * Synchronous version of extractSourceSnippet.
 * Only call this after initTractor() has completed (e.g., after parsing).
 * Returns empty string if positions are invalid.
 */
export function extractSourceSnippetSync(
  source: string,
  start: string | undefined,
  end: string | undefined
): string {
  if (!start || !end) return '';
  if (!initialized) {
    console.warn('extractSourceSnippetSync called before WASM initialized');
    return '';
  }
  try {
    return wasmExtractSourceSnippet(source, start, end);
  } catch {
    return '';
  }
}

/**
 * Synchronous version of getSourceLines.
 * Only call this after initTractor() has completed (e.g., after parsing).
 * Returns empty array if positions are invalid.
 */
export function getSourceLinesSync(
  source: string,
  start: string | undefined,
  end: string | undefined
): string[] {
  if (!start || !end) return [];
  if (!initialized) {
    console.warn('getSourceLinesSync called before WASM initialized');
    return [];
  }
  try {
    const jsonLines = wasmGetSourceLines(source, start, end);
    return JSON.parse(jsonLines);
  } catch {
    return [];
  }
}

// ============================================================================
// Language Info
// ============================================================================

/** Information about a supported language */
export interface LanguageInfo {
  name: string;
  extensions: string[];
  has_transforms: boolean;
  grammar_file: string | null;
}

/**
 * Get detailed information about all supported languages
 */
export async function getLanguageInfo(): Promise<LanguageInfo[]> {
  await initTractor();
  return JSON.parse(wasmGetLanguageInfo());
}

/**
 * Get languages available in web (those with grammar files)
 */
export async function getWebLanguages(): Promise<LanguageInfo[]> {
  await initTractor();
  return JSON.parse(wasmGetWebLanguages());
}

/**
 * Synchronous version of getLanguageInfo.
 * Only call after initTractor() has completed.
 */
export function getLanguageInfoSync(): LanguageInfo[] {
  if (!initialized) {
    console.warn('getLanguageInfoSync called before WASM initialized');
    return [];
  }
  return JSON.parse(wasmGetLanguageInfo());
}

/**
 * Synchronous version of getWebLanguages.
 * Only call after initTractor() has completed.
 */
export function getWebLanguagesSync(): LanguageInfo[] {
  if (!initialized) {
    console.warn('getWebLanguagesSync called before WASM initialized');
    return [];
  }
  return JSON.parse(wasmGetWebLanguages());
}

// ============================================================================
// XPath Validation
// ============================================================================

/** Result of validating an XPath expression */
export interface XPathValidationResult {
  valid: boolean;
  error?: string;
  error_start?: number;
  error_end?: number;
  warnings: string[];
}

/**
 * Validate an XPath expression without executing it
 */
export async function validateXPath(xpath: string): Promise<XPathValidationResult> {
  await initTractor();
  return JSON.parse(wasmValidateXPath(xpath));
}

/**
 * Synchronous version of validateXPath.
 * Only call after initTractor() has completed.
 */
export function validateXPathSync(xpath: string): XPathValidationResult {
  if (!initialized) {
    return { valid: false, error: 'WASM not initialized', warnings: [] };
  }
  return JSON.parse(wasmValidateXPath(xpath));
}

// ============================================================================
// XML Pretty Printing
// ============================================================================

/**
 * Pretty-print an XML string with proper indentation.
 * Only call after initTractor() has completed.
 *
 * @param xml - The XML string to format
 * @param includeLocations - Whether to include start/end/kind attributes
 * @param useColor - Whether to include ANSI color codes
 */
export function prettyPrintXmlSync(
  xml: string,
  includeLocations: boolean = false,
  useColor: boolean = false
): string {
  if (!initialized) {
    console.warn('prettyPrintXmlSync called before WASM initialized');
    return xml;
  }
  try {
    return wasmPrettyPrintXml(xml, includeLocations, useColor);
  } catch {
    return xml; // Return original on error
  }
}

// ============================================================================
// Syntax Highlighting
// ============================================================================

/**
 * Highlight the full source code with syntax coloring based on XML tree.
 * Only call after initTractor() has completed.
 *
 * @param source - The full source code
 * @param xml - Complete XML document with position attributes
 * @param language - The language name (e.g., "csharp", "rust", "typescript")
 * @returns Source code with ANSI color codes for syntax highlighting
 */
export function highlightFullSourceSync(source: string, xml: string, language: string): string {
  if (!initialized) {
    console.warn('highlightFullSourceSync called before WASM initialized');
    return source;
  }
  try {
    return wasmHighlightFullSource(source, xml, language);
  } catch {
    return source;
  }
}

/**
 * Convert ANSI color codes to HTML spans.
 * Supports the codes used by tractor's XML renderer.
 */
export function ansiToHtml(text: string): string {
  // Map ANSI codes to CSS classes (matching tractor brand colors)
  const codeToClass: Record<string, string> = {
    '2': 'ansi-dim',      // DIM (operators, punctuation)
    '1': 'ansi-bold',     // BOLD
    '34': 'ansi-blue',    // BLUE (keywords)
    '36': 'ansi-cyan',    // CYAN (types, functions)
    '33': 'ansi-yellow',  // YELLOW (strings, numbers)
    '32': 'ansi-green',   // GREEN (comments)
    '97': 'ansi-white',   // WHITE (identifiers)
    '30': 'ansi-black',   // BLACK
    '43': 'ansi-bg-yellow', // BG_YELLOW (highlights)
  };

  // Escape HTML entities first
  let escaped = text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // Process character by character, tracking open spans
  let result = '';
  let openSpans = 0;
  let i = 0;

  while (i < escaped.length) {
    // Check for ANSI escape sequence
    if (escaped[i] === '\x1b' && escaped[i + 1] === '[') {
      // Find the end of the sequence (ends with 'm')
      let j = i + 2;
      while (j < escaped.length && escaped[j] !== 'm') {
        j++;
      }

      if (j < escaped.length) {
        const code = escaped.slice(i + 2, j);

        if (code === '0') {
          // RESET - close all open spans
          while (openSpans > 0) {
            result += '</span>';
            openSpans--;
          }
        } else if (codeToClass[code]) {
          // Open a new span
          result += `<span class="${codeToClass[code]}">`;
          openSpans++;
        }
        // Skip codes we don't recognize

        i = j + 1; // Move past the 'm'
        continue;
      }
    }

    result += escaped[i];
    i++;
  }

  // Close any remaining open spans
  while (openSpans > 0) {
    result += '</span>';
    openSpans--;
  }

  return result;
}

/**
 * Convert ANSI-highlighted text to HTML while also inserting match highlight marks.
 * This combines syntax highlighting with match markers without losing either.
 */
export function ansiToHtmlWithMarks(
  ansiText: string,
  matchRanges: Array<{ start: number; end: number; matchIndex: number }>,
  hoveredMatchIndex: number | null
): string {
  const codeToClass: Record<string, string> = {
    '2': 'ansi-dim',
    '1': 'ansi-bold',
    '34': 'ansi-blue',
    '36': 'ansi-cyan',
    '33': 'ansi-yellow',
    '32': 'ansi-green',
    '97': 'ansi-white',
    '30': 'ansi-black',
    '43': 'ansi-bg-yellow',
  };

  // Sort match ranges by start position
  const sortedRanges = [...matchRanges].sort((a, b) => a.start - b.start);

  let result = '';
  let openSyntaxSpans = 0;
  let inMark = false;
  let currentRangeIdx = -1; // Index of the range we're currently inside
  let srcPos = 0; // Position in original source (excludes ANSI codes)
  let nextRangeIdx = 0; // Next range to potentially enter
  let i = 0;

  while (i < ansiText.length) {
    // Check for ANSI escape sequence
    if (ansiText[i] === '\x1b' && ansiText[i + 1] === '[') {
      let j = i + 2;
      while (j < ansiText.length && ansiText[j] !== 'm') {
        j++;
      }

      if (j < ansiText.length) {
        const code = ansiText.slice(i + 2, j);

        if (code === '0') {
          // RESET - close all open syntax spans
          while (openSyntaxSpans > 0) {
            result += '</span>';
            openSyntaxSpans--;
          }
        } else if (codeToClass[code]) {
          result += `<span class="${codeToClass[code]}">`;
          openSyntaxSpans++;
        }

        i = j + 1;
        continue;
      }
    }

    // Before outputting this character, handle mark open/close

    // Close mark if we've reached the end of the current range
    if (inMark && currentRangeIdx >= 0 && srcPos >= sortedRanges[currentRangeIdx].end) {
      result += '</mark>';
      inMark = false;
      currentRangeIdx = -1;
    }

    // Skip past any ranges we've completely passed
    while (nextRangeIdx < sortedRanges.length && sortedRanges[nextRangeIdx].end <= srcPos) {
      nextRangeIdx++;
    }

    // Open mark if we've reached the start of the next range
    if (!inMark && nextRangeIdx < sortedRanges.length && srcPos >= sortedRanges[nextRangeIdx].start) {
      const range = sortedRanges[nextRangeIdx];
      const isHovered = hoveredMatchIndex === range.matchIndex;
      const className = isHovered ? 'highlight highlight-hovered' : 'highlight';
      result += `<mark class="${className}">`;
      inMark = true;
      currentRangeIdx = nextRangeIdx;
      nextRangeIdx++;
    }

    // Output the character (HTML escaped)
    const char = ansiText[i];
    if (char === '&') {
      result += '&amp;';
    } else if (char === '<') {
      result += '&lt;';
    } else if (char === '>') {
      result += '&gt;';
    } else {
      result += char;
    }

    srcPos++;
    i++;
  }

  // Close any remaining marks and spans
  if (inMark) {
    result += '</mark>';
  }
  while (openSyntaxSpans > 0) {
    result += '</span>';
    openSyntaxSpans--;
  }

  return result;
}

// ============================================================================
// Schema Tree
// ============================================================================

/** A node in the schema tree (merged element paths with counts) */
export interface SchemaNode {
  name: string;
  count: number;
  values: string[];
  children: SchemaNode[];
}

/**
 * Get the schema tree for a parsed AST.
 * Returns the same merged element tree as `tractor <file> -o schema`.
 * Only call after initTractor() has completed.
 */
export function getSchemaTreeSync(
  ast: SerializedNode,
  source: string,
  language: string,
  rawMode: boolean = false,
): SchemaNode[] {
  if (!initialized) {
    console.warn('getSchemaTreeSync called before WASM initialized');
    return [];
  }
  try {
    return JSON.parse(wasmGetSchemaTree(JSON.stringify(ast), source, language, rawMode));
  } catch (e) {
    console.error('getSchemaTree error:', e);
    return [];
  }
}
