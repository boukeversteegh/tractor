/**
 * Tractor WASM module wrapper
 */

import type { SerializedNode } from './parser';

// Import the WASM module (generated by wasm-pack)
// @ts-ignore - Module will be generated by wasm-pack
import init, {
  parseToXml,
  parseAstToXml,
  getSupportedLanguages,
  hasTransforms,
  extractSourceSnippet as wasmExtractSourceSnippet,
  getSourceLines as wasmGetSourceLines,
  getLanguageInfo as wasmGetLanguageInfo,
  getWebLanguages as wasmGetWebLanguages,
  validateXPath as wasmValidateXPath,
  prettyPrintXml as wasmPrettyPrintXml,
  highlightFullSource as wasmHighlightFullSource,
} from '../pkg/tractor_core.js';

let initialized = false;

/**
 * Initialize the Tractor WASM module
 */
export async function initTractor(): Promise<void> {
  if (initialized) return;
  await init();
  initialized = true;
}

/** Parse request format */
export interface ParseRequest {
  ast: SerializedNode;
  source: string;
  language: string;
  filePath?: string;
  rawMode?: boolean;
  includeLocations?: boolean;
  prettyPrint?: boolean;
}

/** Parse response format */
export interface ParseResponse {
  xml: string;
  warnings: string[];
}

/**
 * Parse AST to XML using the full request format
 */
export async function parseToXmlFull(request: ParseRequest): Promise<ParseResponse> {
  await initTractor();
  const responseJson = parseToXml(JSON.stringify(request));
  return JSON.parse(responseJson);
}

/**
 * Parse AST to XML using simple parameters
 */
export async function parseAstToXmlSimple(
  ast: SerializedNode,
  source: string,
  language: string,
  rawMode: boolean = false,
  includeLocations: boolean = true,
  prettyPrint: boolean = true
): Promise<string> {
  await initTractor();
  return parseAstToXml(JSON.stringify(ast), source, language, rawMode, includeLocations, prettyPrint);
}

/**
 * Get list of supported languages from the WASM module
 */
export async function getTractorLanguages(): Promise<string[]> {
  await initTractor();
  return JSON.parse(getSupportedLanguages());
}

/**
 * Check if a language has semantic transforms
 */
export async function languageHasTransforms(language: string): Promise<boolean> {
  await initTractor();
  return hasTransforms(language);
}

/**
 * Extract source snippet given start/end positions in "line:col" format
 */
export async function extractSourceSnippet(
  source: string,
  start: string,
  end: string
): Promise<string> {
  await initTractor();
  return wasmExtractSourceSnippet(source, start, end);
}

/**
 * Get full source lines for a range given "line:col" format positions
 * Returns the full lines from start position's line to end position's line
 */
export async function getSourceLines(
  source: string,
  start: string,
  end: string
): Promise<string[]> {
  await initTractor();
  const jsonLines = wasmGetSourceLines(source, start, end);
  return JSON.parse(jsonLines);
}

/**
 * Synchronous version of extractSourceSnippet.
 * Only call this after initTractor() has completed (e.g., after parsing).
 * Returns empty string if positions are invalid.
 */
export function extractSourceSnippetSync(
  source: string,
  start: string | undefined,
  end: string | undefined
): string {
  if (!start || !end) return '';
  if (!initialized) {
    console.warn('extractSourceSnippetSync called before WASM initialized');
    return '';
  }
  try {
    return wasmExtractSourceSnippet(source, start, end);
  } catch {
    return '';
  }
}

/**
 * Synchronous version of getSourceLines.
 * Only call this after initTractor() has completed (e.g., after parsing).
 * Returns empty array if positions are invalid.
 */
export function getSourceLinesSync(
  source: string,
  start: string | undefined,
  end: string | undefined
): string[] {
  if (!start || !end) return [];
  if (!initialized) {
    console.warn('getSourceLinesSync called before WASM initialized');
    return [];
  }
  try {
    const jsonLines = wasmGetSourceLines(source, start, end);
    return JSON.parse(jsonLines);
  } catch {
    return [];
  }
}

// ============================================================================
// Language Info
// ============================================================================

/** Information about a supported language */
export interface LanguageInfo {
  name: string;
  extensions: string[];
  has_transforms: boolean;
  grammar_file: string | null;
}

/**
 * Get detailed information about all supported languages
 */
export async function getLanguageInfo(): Promise<LanguageInfo[]> {
  await initTractor();
  return JSON.parse(wasmGetLanguageInfo());
}

/**
 * Get languages available in web (those with grammar files)
 */
export async function getWebLanguages(): Promise<LanguageInfo[]> {
  await initTractor();
  return JSON.parse(wasmGetWebLanguages());
}

/**
 * Synchronous version of getLanguageInfo.
 * Only call after initTractor() has completed.
 */
export function getLanguageInfoSync(): LanguageInfo[] {
  if (!initialized) {
    console.warn('getLanguageInfoSync called before WASM initialized');
    return [];
  }
  return JSON.parse(wasmGetLanguageInfo());
}

/**
 * Synchronous version of getWebLanguages.
 * Only call after initTractor() has completed.
 */
export function getWebLanguagesSync(): LanguageInfo[] {
  if (!initialized) {
    console.warn('getWebLanguagesSync called before WASM initialized');
    return [];
  }
  return JSON.parse(wasmGetWebLanguages());
}

// ============================================================================
// XPath Validation
// ============================================================================

/** Result of validating an XPath expression */
export interface XPathValidationResult {
  valid: boolean;
  error?: string;
  error_start?: number;
  error_end?: number;
  warnings: string[];
}

/**
 * Validate an XPath expression without executing it
 */
export async function validateXPath(xpath: string): Promise<XPathValidationResult> {
  await initTractor();
  return JSON.parse(wasmValidateXPath(xpath));
}

/**
 * Synchronous version of validateXPath.
 * Only call after initTractor() has completed.
 */
export function validateXPathSync(xpath: string): XPathValidationResult {
  if (!initialized) {
    return { valid: false, error: 'WASM not initialized', warnings: [] };
  }
  return JSON.parse(wasmValidateXPath(xpath));
}

// ============================================================================
// XML Pretty Printing
// ============================================================================

/**
 * Pretty-print an XML string with proper indentation.
 * Only call after initTractor() has completed.
 *
 * @param xml - The XML string to format
 * @param includeLocations - Whether to include start/end/kind attributes
 * @param useColor - Whether to include ANSI color codes
 */
export function prettyPrintXmlSync(
  xml: string,
  includeLocations: boolean = false,
  useColor: boolean = false
): string {
  if (!initialized) {
    console.warn('prettyPrintXmlSync called before WASM initialized');
    return xml;
  }
  try {
    return wasmPrettyPrintXml(xml, includeLocations, useColor);
  } catch {
    return xml; // Return original on error
  }
}

// ============================================================================
// Syntax Highlighting
// ============================================================================

/**
 * Highlight the full source code with syntax coloring based on XML tree.
 * Only call after initTractor() has completed.
 *
 * @param source - The full source code
 * @param xml - Complete XML document with position attributes
 * @returns Source code with ANSI color codes for syntax highlighting
 */
export function highlightFullSourceSync(source: string, xml: string): string {
  if (!initialized) {
    console.warn('highlightFullSourceSync called before WASM initialized');
    return source;
  }
  try {
    return wasmHighlightFullSource(source, xml);
  } catch {
    return source;
  }
}

/**
 * Convert ANSI color codes to HTML spans.
 * Supports the codes used by tractor's XML renderer.
 */
export function ansiToHtml(text: string): string {
  // Map ANSI codes to CSS classes (matching tractor brand colors)
  const codeToClass: Record<string, string> = {
    '2': 'ansi-dim',      // DIM (operators, punctuation)
    '1': 'ansi-bold',     // BOLD
    '34': 'ansi-blue',    // BLUE (keywords)
    '36': 'ansi-cyan',    // CYAN (types, functions)
    '33': 'ansi-yellow',  // YELLOW (strings, numbers)
    '32': 'ansi-green',   // GREEN (comments)
    '97': 'ansi-white',   // WHITE (identifiers)
    '30': 'ansi-black',   // BLACK
    '43': 'ansi-bg-yellow', // BG_YELLOW (highlights)
  };

  // Escape HTML entities first
  let escaped = text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // Process character by character, tracking open spans
  let result = '';
  let openSpans = 0;
  let i = 0;

  while (i < escaped.length) {
    // Check for ANSI escape sequence
    if (escaped[i] === '\x1b' && escaped[i + 1] === '[') {
      // Find the end of the sequence (ends with 'm')
      let j = i + 2;
      while (j < escaped.length && escaped[j] !== 'm') {
        j++;
      }

      if (j < escaped.length) {
        const code = escaped.slice(i + 2, j);

        if (code === '0') {
          // RESET - close all open spans
          while (openSpans > 0) {
            result += '</span>';
            openSpans--;
          }
        } else if (codeToClass[code]) {
          // Open a new span
          result += `<span class="${codeToClass[code]}">`;
          openSpans++;
        }
        // Skip codes we don't recognize

        i = j + 1; // Move past the 'm'
        continue;
      }
    }

    result += escaped[i];
    i++;
  }

  // Close any remaining open spans
  while (openSpans > 0) {
    result += '</span>';
    openSpans--;
  }

  return result;
}
